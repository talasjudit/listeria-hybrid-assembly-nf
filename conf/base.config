/*
========================================================================================
    Base Configuration - Process Resource Allocations
========================================================================================
    This configuration file defines resource requirements for all processes.

    Resource Strategy:
    - Each process has dedicated resource blocks that can be tuned
    - Resources scale with task.attempt for automatic retry with more resources
    - The check_max() function ensures resources don't exceed user-defined limits

    Customization:
    - Adjust CPU, memory, and time values during testing and optimization
    - Resources are intentionally conservative and should be tuned for your data
    - For retry behavior, resources multiply by task.attempt on each retry
========================================================================================
*/

process {

    /*
     * Default Error Handling Strategy
     * Retry on resource-related exit codes, fail on other errors
     *
     * Exit codes that trigger retry:
     * 143 = SIGTERM (terminated)
     * 137 = SIGKILL (killed, usually OOM)
     * 104 = Connection reset
     * 134 = SIGABRT (aborted)
     * 139 = SIGSEGV (segmentation fault)
     */
    errorStrategy = { task.exitStatus in [143,137,104,134,139] ? 'retry' : 'finish' }
    maxRetries    = 1
    maxErrors     = '-1'

    /*
     * Default Resource Allocations
     * These apply to any process without a specific resource block
     */
    cpus   = { check_max( 1, 'cpus' ) }
    memory = { check_max( 4.GB, 'memory' ) }
    time   = { check_max( 1.h, 'time' ) }

    /*
     * ============================================================================
     *                       PROCESS-SPECIFIC RESOURCES
     * ============================================================================
     * Adjust these values based on your data and infrastructure
     * Resources scale with task.attempt: on retry, multiply by attempt number
     */

    /*
     * FASTP - Illumina Read QC and Trimming
     * Memory intensive for high-coverage data
     * CPU scales well with thread count
     */
    withName: 'FASTP' {
        cpus   = { check_max( 6 * task.attempt, 'cpus' ) }
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 4.h * task.attempt, 'time' ) }
    }

    /*
     * PORECHOP_ABI - Nanopore Adapter Trimming
     * CPU intensive, moderate memory usage
     * Scales well with thread count
     */
    withName: 'PORECHOP_ABI' {
        cpus   = { check_max( 6 * task.attempt, 'cpus' ) }
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 4.h * task.attempt, 'time' ) }
    }

    /*
     * FILTLONG - Nanopore Read Quality Filtering
     * Single-threaded, moderate memory usage
     */
    withName: 'FILTLONG' {
        cpus   = { check_max( 4, 'cpus' ) }
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h, 'time' ) }
    }

    /*
     * FLYE - Long-Read Assembly
     * Very CPU and memory intensive
     * One of the most resource-hungry processes in the pipeline
     * Adjust based on genome size and read coverage
     */
    withName: 'FLYE' {
        cpus   = { check_max( 12 * task.attempt, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 24.h * task.attempt, 'time' ) }
    }

    /*
     * UNICYCLER and UNICYCLER_WITH_FLYE - Hybrid Assembly
     * Very CPU and memory intensive
     * Runtime highly variable depending on data complexity
     * Use same resources for both Unicycler processes
     */
    withName: 'UNICYCLER|UNICYCLER_WITH_FLYE' {
        cpus   = { check_max( 12 * task.attempt, 'cpus' ) }
        memory = { check_max( 32.GB * task.attempt, 'memory' ) }
        time   = { check_max( 24.h * task.attempt, 'time' ) }
    }

    /*
     * CHECKM2 - Assembly Completeness Assessment
     * CPU intensive, moderate memory
     * Database included in container
     */
    withName: 'CHECKM2' {
        cpus   = { check_max( 8 * task.attempt, 'cpus' ) }
        memory = { check_max( 16.GB * task.attempt, 'memory' ) }
        time   = { check_max( 6.h * task.attempt, 'time' ) }
    }

    /*
     * QUAST - Assembly Statistics
     * Light resource requirements
     * Fast execution
     */
    withName: 'QUAST' {
        cpus   = { check_max( 4, 'cpus' ) }
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h, 'time' ) }
    }

    /*
     * MULTIQC - Aggregate QC Report
     * Light resource requirements
     * Collects and processes all QC outputs
     */
    withName: 'MULTIQC' {
        cpus   = { check_max( 4, 'cpus' ) }
        memory = { check_max( 8.GB * task.attempt, 'memory' ) }
        time   = { check_max( 2.h, 'time' ) }
    }
}

/*
========================================================================================
    HELPER FUNCTIONS
========================================================================================
*/

/**
 * Check that requested resources don't exceed user-defined maximums
 *
 * This function compares requested resources against params.max_* values
 * and returns the smaller of the two, ensuring processes never request
 * more resources than available on the system.
 *
 * @param obj The requested resource value
 * @param type The resource type: 'memory', 'time', or 'cpus'
 * @return The constrained resource value
 */
def check_max(obj, type) {
    if (type == 'memory') {
        try {
            if (obj.compareTo(params.max_memory as nextflow.util.MemoryUnit) == 1)
                return params.max_memory as nextflow.util.MemoryUnit
            else
                return obj
        } catch (all) {
            println "WARNING: Invalid max memory '${params.max_memory}', using default: $obj"
            return obj
        }
    } else if (type == 'time') {
        try {
            if (obj.compareTo(params.max_time as nextflow.util.Duration) == 1)
                return params.max_time as nextflow.util.Duration
            else
                return obj
        } catch (all) {
            println "WARNING: Invalid max time '${params.max_time}', using default: $obj"
            return obj
        }
    } else if (type == 'cpus') {
        try {
            return Math.min( obj, params.max_cpus as int )
        } catch (all) {
            println "WARNING: Invalid max cpus '${params.max_cpus}', using default: $obj"
            return obj
        }
    }
}
